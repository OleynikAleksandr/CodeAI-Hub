# Спецификация автономного ядра CodeAI-Hub (Core Orchestrator)

**Версия:** 0.1.6-draft
**Дата:** 2025-10-24
**Статус:** Черновик для обсуждения
**Фаза:** Phase 10А

---

## 1. Обзор и назначение

### 1.1. Цель документа
Данная спецификация описывает функциональные и нефункциональные требования к автономному ядру CodeAI-Hub (Core Orchestrator), его архитектуру, API, контракты взаимодействия и жизненный цикл. Документ является основой для проектирования (Phase 11) и реализации (Phase 12-14) ядра.

### 1.2. Что такое Core Orchestrator
Core Orchestrator — это автономный Node.js-сервис, который:
- Работает независимо от VS Code и других клиентов
- Управляет жизненным циклом AI-сессий
- Обеспечивает единую точку интеграции с провайдерами (Claude, Codex, Gemini)
- Предоставляет HTTP/WebSocket API для подключения множественных клиентов
- Автоматически устанавливает и обновляет провайдерные модули
- **Является единственным источником правды (single source of truth)** — все данные, состояние, настройки хранятся только в ядре
- **UI клиенты — это только отображение** — они не хранят данные локально, только получают и отображают состояние от ядра
- Синхронизирует состояние между всеми подключёнными клиентами в реальном времени
- Работает пока есть хотя бы один подключенный клиент
- Автоматически завершается через 1 минуту после отключения последнего клиента

### 1.3. Проблемы, которые решает ядро
- **Дублирование логики**: без ядра каждый клиент (VS Code, CEF, mobile) должен реализовывать логику провайдеров независимо
- **Размер VSIX**: встраивание всех зависимостей увеличивает размер расширения и усложняет обновления
- **Мультисессионность**: сложно синхронизировать состояние между разными клиентами без центрального сервиса
- **Обновления**: обновление ядра происходит через обновление VSIX расширения (избегаем необходимости цифровых подписей и developer accounts)
- **Персистентность**: сессии переживают перезапуск клиентов и VS Code

---

## 2. Пользовательские сценарии (User Journeys)

### 2.1. Первая установка и запуск
**Актор**: Пользователь, впервые устанавливающий расширение

1. Пользователь устанавливает VSIX из VS Code Marketplace
2. При первой активации расширение:
   - Скачивает автономное ядро из публичного репозитория в `~/.codeai-hub/core/<version>/`
   - Устанавливает зависимости ядра (express, ws и др.)
   - Генерирует начальную конфигурацию `config.json`
   - Запускает процесс ядра в фоновом режиме на `127.0.0.1:8080`
3. Расширение ожидает подключения к ядру через WebSocket (timeout 15 секунд)
4. При успешном подключении — UI готов к работе (молча, без уведомлений)
5. При ошибке подключения (timeout/connection refused) — показывается сообщение об ошибке с диагностической информацией
6. Пользователь нажимает кнопку **"New Session"**
7. Открывается окно выбора провайдера, где отображаются **все провайдеры, подключённые к ядру** (за исключением отключённых пользователем в Settings)
8. Пользователь выбирает одного или нескольких провайдеров для сессии
9. Создаётся новая сессия с выбранными провайдерами

**Ожидаемый результат**: Пользователь готов к работе без лишних уведомлений, выбирает провайдера при создании сессии

> **Примечание**: В Settings пользователь может отключать провайдеры — они не будут отображаться в окне выбора при создании новой сессии. Механизм установки и авторизации провайдеров будет описан отдельно.

### 2.2. Ежедневная работа с сессиями и синхронизация между UI
**Актор**: Пользователь, работающий с несколькими AI-сессиями в двух UI одновременно

1. Пользователь открывает VS Code
2. Расширение автоматически запускает ядро (если оно не запущено)
3. Ядро восстанавливает все открытые сессии через resume по сохранённым sessionId
4. В webview отображаются восстановленные сессии из предыдущего сеанса
5. Пользователь создаёт новую сессию с провайдером Codex **в webview**
6. Параллельно открывает локальный CEF-клиент
7. CEF-клиент подключается к тому же ядру и **мгновенно отображает** все те же сессии, включая только что созданную с Codex
8. Пользователь отправляет сообщение в webview — **оно мгновенно отображается в CEF-клиенте**
9. Провайдер начинает отвечать — **потоковый ответ отображается одновременно в обоих UI**
10. Пользователь переключается в CEF-клиент и **открывает Settings**
11. Отключает провайдера Gemini в настройках CEF-клиента
12. В **webview VS Code Settings** изменение **мгновенно отображается** — Gemini также отключён
13. Пользователь создаёт ещё одну сессию **в CEF-клиенте** — она **мгновенно появляется в webview**
14. Пользователь закрывает VS Code, но CEF-клиент остаётся открытым — ядро продолжает работу, сессии доступны
15. Пользователь закрывает CEF-клиент — последний клиент отключен
16. Ядро ожидает 1 минуту на случай повторного подключения
17. Через 1 минуту ядро останавливает все процессы провайдеров и завершается gracefully
18. На следующий день пользователь открывает VS Code — ядро запускается заново, **все сессии и настройки** восстанавливаются

**Ожидаемый результат**:
- Полная синхронизация между VS Code webview и CEF-клиентом
- Изменения в одном UI мгновенно отображаются в другом
- Идентичный опыт независимо от выбранного интерфейса
- Экономное использование ресурсов с автоматическим восстановлением состояния

### 2.3. Обновление системы
**Актор**: Пользователь, у которого выходит новая версия расширения

1. VS Code уведомляет о доступном обновлении расширения
2. Пользователь обновляет VSIX
3. При активации расширение проверяет версию ядра
4. Обнаруживается несоответствие версий
5. Расширение скачивает новую версию ядра параллельно с работой старой
6. После скачивания предлагает пользователю перезапустить ядро
7. Пользователь подтверждает
8. Ядро корректно завершает текущие операции
9. Все подключённые клиенты получают уведомление `core:restarting`
10. Запускается новая версия ядра
11. Клиенты переподключаются автоматически
12. Все сессии восстанавливаются из персистентного хранилища

**Ожидаемый результат**: Бесшовное обновление с минимальным downtime

### 2.4. Работа с несколькими провайдерами
**Актор**: Пользователь, использующий Claude и Codex одновременно

1. Пользователь создаёт сессию с Claude для code review
2. В параллельной сессии использует Codex для генерации кода
3. Claude достигает rate limit
4. Ядро уведомляет пользователя и предлагает переключиться на резервного провайдера
5. Пользователь переключает сессию на Gemini
6. Контекст диалога сохраняется, работа продолжается
7. В настройках пользователь просматривает статистику использования по провайдерам
8. Видит оставшиеся квоты и время их обновления

**Ожидаемый результат**: Гибкое переключение провайдеров без потери контекста

### 2.5. Удалённый доступ (перспективная функция, не для MVP)
**Актор**: Пользователь, работающий с планшета

> **Примечание**: Этот сценарий относится к будущей функциональности и не будет реализован в начальных фазах (Phase 11-14). Документируется для полноты картины.

1. Пользователь настраивает Remote UI Bridge на своём компьютере
2. Включает HTTPS и TOTP-аутентификацию
3. На планшете открывает веб-интерфейс по адресу `https://my-machine.local:8443`
4. Вводит TOTP-код из Google Authenticator
5. Получает короткоживущий JWT токен и подключается к ядру
6. Видит все свои сессии, может создавать новые
7. Отправляет сообщения, получает ответы в реальном времени
8. При потере соединения интерфейс автоматически переподключается

**Ожидаемый результат**: Доступ к сессиям с любого устройства

---

## 3. Функциональные требования

### 3.1. Управление жизненным циклом
- **F-01**: Ядро должно запускаться автоматически при подключении первого клиента (VS Code расширение или CEF-клиент)
- **F-02**: Ядро должно работать пока есть хотя бы один активный WebSocket-клиент
- **F-03**: Ядро должно отслеживать количество подключенных клиентов через WebSocket подключения
- **F-04**: Ядро должно выполнять graceful shutdown через 1 минуту после отключения последнего клиента (grace period для переподключения)
- **F-05**: Ядро должно автоматически восстанавливать все открытые в UI сессии при запуске через механизм resume по сохранённым sessionId
- **F-06**: Ядро должно поддерживать команду VS Code расширения `CodeAI Hub: Stop Core` для принудительной остановки с сохранением состояния
- **F-07**: Ядро должно поддерживать команду VS Code расширения `CodeAI Hub: Restart Core` для перезапуска с уведомлением всех клиентов

### 3.2. Управление сессиями

#### Текущие требования
- **F-08**: Ядро должно поддерживать множественные одновременные сессии с одним провайдером или с разными провайдерами

> **Примечание**: Персистентность диалогов, resume, экспорт/импорт для обычных сессий обеспечивают сами провайдеры через свои механизмы.

#### Перспективные требования (комбинированные сессии с несколькими провайдерами)
- **F-09**: Для смешанных сессий ядро должно назначать уникальный идентификатор (UUID) независимый от провайдеров
- **F-10**: Для смешанных сессий ядро должно персистировать историю диалогов в унифицированном JSONL-формате
- **F-11**: Для смешанных сессий ядро должно поддерживать pause/resume независимо от состояния отдельных провайдеров
- **F-12**: Для смешанных сессий ядро должно поддерживать экспорт/импорт полного контекста всех участвующих провайдеров

### 3.3. Управление провайдерами
- **F-13**: Ядро должно динамически загружать провайдерные модули
- **F-14**: Ядро должно проверять совместимость версий модулей
- **F-15**: Ядро должно автоматически устанавливать CLI/SDK провайдеров
- **F-16**: Ядро должно обновлять провайдеры без остановки других сессий
- **F-17**: Ядро должно изолировать данные разных провайдеров
- **F-18**: Ядро должно отслеживать квоты и лимиты провайдеров
- **F-19**: Ядро должно предоставлять единый унифицированный врапер (Provider Event Adapter) для нормализации всех типов событий от всех провайдеров в единый формат для UI
  - Сходные типы событий (message, thinking, tool_call, error) должны преобразовываться в идентичный формат независимо от провайдера
  - Уникальные события конкретного провайдера должны поддерживаться через расширяемую схему с сохранением стилистической идентичности
  - Врапер должен работать как для потоковых событий (real-time SDK фидбэк), так и для персистентных данных (локальные JSONL файлы)
- **F-20**: Ядро должно предоставлять список всех подключённых провайдеров для отображения в UI
  - При нажатии "New Session" UI показывает окно выбора со всеми активными провайдерами
  - Пользователь может отключать/включать провайдеры через Settings — отключённые провайдеры не отображаются в списке выбора
  - Список провайдеров синхронизируется между всеми подключёнными клиентами

### 3.4. Remote UI Bridge

#### Текущие требования (локальные подключения)
- **F-21**: Ядро должно предоставлять HTTP API для управления (health check, status, config) на `127.0.0.1:8080`
- **F-22**: Ядро должно предоставлять WebSocket API для real-time коммуникации на `127.0.0.1:8080`
- **F-23**: Ядро должно поддерживать множественные одновременные подключения от локальных клиентов (VS Code webview + CEF-клиент одновременно)
- **F-24**: Ядро должно синхронизировать ВСЁ состояние между всеми подключёнными клиентами в реальном времени:
  - **Сессии**: создание, удаление, обновление статуса
  - **Сообщения**: все входящие/исходящие сообщения в любой сессии мгновенно отображаются во всех UI
  - **Настройки**: изменения в Settings одного UI немедленно применяются в другом
  - **Список провайдеров**: включение/отключение провайдеров синхронизируется
  - **Состояние UI**: открытые вкладки, активная сессия, фокус (опционально)
- **F-25**: UI клиенты НЕ должны хранить данные локально — они являются только отображением (view), все данные хранятся в ядре
- **F-26**: При подключении нового клиента ядро должно отправить полный снимок текущего состояния (initial state sync)

> **Архитектурный принцип**: Ядро — это единственный источник правды (single source of truth). UI — это stateless view, который только отображает данные от ядра. Это обеспечивает идентичный опыт во всех клиентах.

> **Примечание**: Для локальных подключений (VS Code расширение, CEF-клиент) авторизация НЕ требуется. Ядро bind только на `127.0.0.1`.

#### Перспективные требования (удалённый доступ)
- **F-27**: Ядро должно поддерживать bind на внешние интерфейсы для удалённого доступа (опционально)
- **F-28**: Ядро должно поддерживать HTTPS для удалённых подключений (опционально)
- **F-29**: Ядро должно поддерживать авторизацию по JWT токенам для удалённых клиентов (опционально)
- **F-30**: Ядро должно поддерживать TOTP-аутентификацию для удалённого доступа (опционально)

### 3.5. Конфигурация и хранилище
- **F-31**: Ядро должно читать конфигурацию из `~/.codeai-hub/core/config.json`
- **F-32**: Ядро должно сохранять секреты в системном keychain
- **F-33**: Ядро должно поддерживать горячую перезагрузку конфигурации
- **F-34**: Ядро должно версионировать схему конфигурации
- **F-35**: Ядро должно создавать резервные копии данных

### 3.6. Логирование и диагностика
- **F-36**: Ядро должно вести структурированные логи в `~/.codeai-hub/logs/`
- **F-37**: Ядро должны поддерживать уровни логирования (debug, info, warn, error)
- **F-38**: Ядро должно ротировать логи по размеру/времени
- **F-39**: Ядро должно экспортировать диагностические данные по запросу
- **F-40**: Ядро должно собирать метрики производительности (опционально)

---

## 4. Архитектурные компоненты

### 4.1. Структура модулей

```
packages/core/
├── src/
│   ├── index.ts                    # Точка входа
│   ├── orchestrator/               # Core Orchestrator
│   │   ├── orchestrator.ts         # Главный координатор
│   │   ├── lifecycle-manager.ts    # Управление запуском/остановкой
│   │   └── event-router.ts         # Маршрутизация событий
│   ├── session-manager/            # Session Manager
│   │   ├── session-manager.ts      # Управление сессиями
│   │   ├── session-store.ts        # Персистентность сессий
│   │   └── session-context.ts      # Контекст сессии
│   ├── provider-registry/          # Provider Registry
│   │   ├── registry.ts             # Реестр провайдеров
│   │   ├── loader.ts               # Загрузка модулей
│   │   └── provider-adapter.ts     # Адаптеры провайдеров
│   ├── event-adapter/              # Provider Event Adapter (Unified Wrapper)
│   │   ├── event-normalizer.ts     # Нормализация событий от провайдеров
│   │   ├── schema-mapper.ts        # Маппинг схем провайдеров в единый формат
│   │   └── event-types.ts          # Унифицированные типы событий
│   ├── remote-bridge/              # Remote UI Bridge
│   │   ├── http-server.ts          # HTTP API
│   │   ├── websocket-hub.ts        # WebSocket hub
│   │   ├── auth-middleware.ts      # Авторизация
│   │   └── message-validator.ts    # Валидация сообщений
│   ├── config/                     # Configuration
│   │   ├── config-loader.ts        # Загрузка конфигурации
│   │   ├── secrets-manager.ts      # Управление секретами
│   │   └── schema.ts               # Схемы конфигурации
│   └── telemetry/                  # Telemetry & Logging
│       ├── logger.ts               # Структурированное логирование
│       ├── metrics.ts              # Сбор метрик
│       └── diagnostics.ts          # Диагностика
├── package.json
└── tsconfig.json
```

### 4.2. Core Orchestrator
**Ответственность**: Центральная координация всех компонентов

**Основные функции**:
- Инициализация и остановка всех модулей
- Маршрутизация событий между компонентами
- Управление жизненным циклом сервиса
- Координация провайдеров и сессий

**Интерфейсы**:
```typescript
interface ICoreOrchestrator {
  start(): Promise<void>;
  stop(): Promise<void>;
  restart(): Promise<void>;
  getStatus(): OrchestratorStatus;
  on(event: string, handler: Function): void;
  emit(event: string, data: any): void;
}
```

### 4.3. Session Manager
**Ответственность**: Управление жизненным циклом сессий

**Основные функции**:
- Создание, приостановка, возобновление, удаление сессий
- Персистентность диалогов в JSONL
- Управление контекстом сессий
- Выгрузка холодных сессий

**Интерфейсы**:
```typescript
interface ISessionManager {
  createSession(request: CreateSessionRequest): Promise<Session>;
  getSession(sessionId: string): Promise<Session | null>;
  pauseSession(sessionId: string): Promise<void>;
  resumeSession(sessionId: string): Promise<void>;
  deleteSession(sessionId: string): Promise<void>;
  listSessions(filter?: SessionFilter): Promise<Session[]>;
  persistSession(session: Session): Promise<void>;
}
```

### 4.4. Provider Registry
**Ответственность**: Управление провайдерными модулями

**Основные функции**:
- Регистрация и деактивация провайдеров
- Загрузка модулей из публичных источников
- Проверка версий и совместимости
- Изоляция данных провайдеров

**Интерфейсы**:
```typescript
interface IProviderRegistry {
  registerProvider(provider: ProviderModule): void;
  unregisterProvider(providerId: string): void;
  getProvider(providerId: string): ProviderModule | null;
  listProviders(): ProviderMetadata[];
  installProvider(providerId: string): Promise<void>;
  updateProvider(providerId: string): Promise<void>;
  getCapabilities(providerId: string): ProviderCapabilities;
}
```

### 4.5. Provider Event Adapter (Unified Wrapper)
**Ответственность**: Нормализация событий от всех провайдеров в единый формат для UI

**Назначение**:
Это критически важный модуль, который обеспечивает единообразное отображение данных от разных провайдеров в UI. Каждый провайдер (Claude, Codex, Gemini) имеет собственный формат событий и данных — как в потоковых SDK фидбэках, так и в локальных JSONL файлах сессий. Provider Event Adapter преобразует все эти форматы в единую схему.

**Основные функции**:
- Анализ и каталогизация всех типов событий от всех провайдеров
- Нормализация сходных событий (message, thinking, tool_call, error) в идентичный формат
- Поддержка уникальных событий конкретного провайдера через расширяемую схему
- Обеспечение стилистической идентичности всех событий в UI
- Работа как с real-time потоковыми событиями, так и с персистентными JSONL данными

**Интерфейсы**:
```typescript
interface IProviderEventAdapter {
  // Нормализация одного события от провайдера
  normalizeEvent(providerId: string, rawEvent: any): UnifiedEvent;

  // Пакетная нормализация (для JSONL файлов)
  normalizeEventBatch(providerId: string, rawEvents: any[]): UnifiedEvent[];

  // Регистрация кастомного маппера для уникальных событий провайдера
  registerCustomMapper(providerId: string, eventType: string, mapper: EventMapper): void;

  // Получение схемы унифицированных событий
  getUnifiedSchema(): EventSchema;
}

// Унифицированный формат события
type UnifiedEvent =
  | { type: 'message', role: 'user' | 'assistant', content: string, timestamp: string }
  | { type: 'thinking', content: string, timestamp: string }
  | { type: 'tool_call', name: string, args: object, callId: string, timestamp: string }
  | { type: 'tool_result', callId: string, result: any, timestamp: string }
  | { type: 'status', status: string, message?: string, timestamp: string }
  | { type: 'error', code: string, message: string, recoverable: boolean, timestamp: string }
  | { type: 'custom', providerId: string, data: object, timestamp: string }; // Для уникальных событий
```

**Требования к анализу**:
- Документировать все типы событий Claude (из claude-code CLI и @anthropic-ai/claude-agent-sdk)
- Документировать все типы событий Codex (из OpenAI API)
- Документировать все типы событий Gemini (из Google AI SDK)
- Создать матрицу соответствия событий разных провайдеров
- Определить базовую схему унифицированных событий
- Разработать стратегию расширения схемы для будущих провайдеров

### 4.6. Remote UI Bridge
**Ответственность**: API для подключения клиентов

**Основные функции**:
- HTTP API для управления (GET /health, POST /sessions, etc.)
- WebSocket для real-time событий
- Авторизация по токенам
- Синхронизация состояния между клиентами

**Интерфейсы**:
```typescript
interface IRemoteBridge {
  startServer(config: ServerConfig): Promise<void>;
  stopServer(): Promise<void>;
  authenticateClient(token: string): Promise<ClientSession>;
  broadcast(event: BridgeEvent): void;
  sendToClient(clientId: string, event: BridgeEvent): void;
}
```

### 4.7. Config & Secrets Manager
**Ответственность**: Управление конфигурацией и секретами

**Основные функции**:
- Загрузка конфигурации из файла
- Горячая перезагрузка настроек
- Сохранение секретов в системном keychain
- Валидация схемы конфигурации

**Интерфейсы**:
```typescript
interface IConfigManager {
  load(): Promise<CoreConfig>;
  reload(): Promise<void>;
  get<T>(key: string): T;
  set(key: string, value: any): Promise<void>;
}

interface ISecretsManager {
  setSecret(key: string, value: string): Promise<void>;
  getSecret(key: string): Promise<string | null>;
  deleteSecret(key: string): Promise<void>;
}
```

### 4.8. Telemetry & Logging
**Ответственность**: Логирование и диагностика

**Основные функции**:
- Структурированное логирование (JSON)
- Ротация логов
- Сбор метрик производительности
- Экспорт диагностических данных

**Интерфейсы**:
```typescript
interface ILogger {
  debug(message: string, context?: object): void;
  info(message: string, context?: object): void;
  warn(message: string, context?: object): void;
  error(message: string, error: Error, context?: object): void;
}
```

---

## 5. API спецификация

### 5.1. HTTP API

#### 5.1.1. Health Check
```http
GET /api/v1/health
```
**Response**:
```json
{
  "status": "ok",
  "version": "0.1.0",
  "uptime": 3600,
  "activeSessions": 5
}
```

#### 5.1.2. Get Status
```http
GET /api/v1/status
Authorization: Bearer <token>
```
**Response**:
```json
{
  "core": {
    "version": "0.1.0",
    "uptime": 3600,
    "pid": 12345
  },
  "providers": [
    {
      "id": "claude",
      "version": "1.22.0",
      "status": "active",
      "sessions": 2
    }
  ],
  "sessions": [
    {
      "id": "sess-123",
      "providerId": "claude",
      "status": "active",
      "createdAt": "2025-10-24T10:00:00Z"
    }
  ]
}
```

#### 5.1.3. Create Session
```http
POST /api/v1/sessions
Authorization: Bearer <token>
Content-Type: application/json

{
  "providerId": "claude",
  "settings": {
    "model": "claude-sonnet-4",
    "streaming": true
  }
}
```
**Response**:
```json
{
  "sessionId": "sess-456",
  "status": "created",
  "wsUrl": "ws://localhost:8080/api/v1/sessions/sess-456/stream"
}
```

#### 5.1.4. Get Session
```http
GET /api/v1/sessions/{sessionId}
Authorization: Bearer <token>
```

#### 5.1.5. Delete Session
```http
DELETE /api/v1/sessions/{sessionId}
Authorization: Bearer <token>
```

#### 5.1.6. List Providers
```http
GET /api/v1/providers
Authorization: Bearer <token>
```

#### 5.1.7. Shutdown Core
```http
POST /api/v1/core/shutdown
Authorization: Bearer <token>
```

### 5.2. WebSocket API

#### 5.2.1. Подключение
```javascript
const ws = new WebSocket('ws://localhost:8080/api/v1/stream?token=<token>');
```

#### 5.2.2. Формат сообщений

**Client → Server**:
```json
{
  "type": "session:create" | "session:message" | "session:stop",
  "sessionId": "sess-123",
  "payload": { ... }
}
```

**Server → Client**:
```json
{
  "type": "session:update" | "stream:chunk" | "workflow:event" | "error",
  "sessionId": "sess-123",
  "payload": { ... },
  "timestamp": "2025-10-24T10:00:00Z"
}
```

#### 5.2.3. Типы событий

**`session:update`** - обновление состояния сессии:
```json
{
  "type": "session:update",
  "sessionId": "sess-123",
  "payload": {
    "status": "active" | "paused" | "stopped",
    "messageCount": 10
  }
}
```

**`stream:chunk`** - потоковый вывод от провайдера:
```json
{
  "type": "stream:chunk",
  "sessionId": "sess-123",
  "payload": {
    "role": "assistant",
    "content": "Hello world",
    "delta": true
  }
}
```

**`workflow:event`** - системные события:
```json
{
  "type": "workflow:event",
  "payload": {
    "event": "provider:quota_warning",
    "providerId": "claude",
    "remaining": 100
  }
}
```

**`error`** - ошибки:
```json
{
  "type": "error",
  "sessionId": "sess-123",
  "payload": {
    "code": "PROVIDER_ERROR",
    "message": "Claude API rate limit exceeded",
    "recoverable": true,
    "actions": ["switch_provider", "retry_later"]
  }
}
```

---

## 6. Контракты провайдеров

### 6.1. Интерфейс провайдерного модуля
```typescript
interface IProviderModule {
  // Метаданные
  id: string;
  name: string;
  version: string;
  
  // Жизненный цикл
  installOrUpdate(context: InstallContext): Promise<InstallResult>;
  configure(settings: ProviderSettings): Promise<void>;
  
  // Сессии
  startSession(request: StartSessionRequest): Promise<SessionDescriptor>;
  stopSession(sessionId: string): Promise<void>;
  
  // Потоковая передача
  streamEvents(sessionId: string): AsyncIterator<ProviderEvent>;
  
  // Возможности
  getCapabilities(): ProviderCapabilities;
}
```

### 6.2. Адаптеры событий
Каждый провайдер должен преобразовывать свои события в унифицированный формат:

```typescript
type UnifiedEvent =
  | { type: 'message', role: 'user' | 'assistant', content: string }
  | { type: 'tool_call', name: string, args: object }
  | { type: 'tool_result', callId: string, result: any }
  | { type: 'status', status: string, message?: string }
  | { type: 'thinking', content: string }
  | { type: 'error', error: Error };
```

---

## 7. Схемы данных

### 7.1. Конфигурация ядра
```json
{
  "version": "0.1.0",
  "core": {
    "port": 8080,
    "host": "127.0.0.1",
    "logLevel": "info",
    "dataDir": "~/.codeai-hub"
  },
  "bridge": {
    "enabled": true,
    "https": false,
    "auth": {
      "type": "token",
      "tokenExpiry": 86400
    }
  },
  "providers": {
    "autoUpdate": true,
    "checkInterval": 3600
  },
  "sessions": {
    "maxConcurrent": 10,
    "coldStorageTimeout": 3600,
    "persistenceFormat": "jsonl"
  }
}
```

### 7.2. Session Schema
```json
{
  "id": "sess-123",
  "providerId": "claude",
  "status": "active",
  "createdAt": "2025-10-24T10:00:00Z",
  "updatedAt": "2025-10-24T10:30:00Z",
  "messages": [
    {
      "id": "msg-1",
      "role": "user",
      "content": "Hello",
      "timestamp": "2025-10-24T10:00:00Z"
    }
  ],
  "metadata": {
    "title": "Code Review Session",
    "tags": ["review", "typescript"]
  }
}
```

### 7.3. Provider Metadata
```json
{
  "id": "claude",
  "name": "Anthropic Claude",
  "version": "1.22.0",
  "capabilities": {
    "streaming": true,
    "toolUse": true,
    "fileOps": true,
    "thinking": true
  },
  "dependencies": {
    "cli": "claude-code>=1.22.0",
    "sdk": "@anthropic-ai/claude-agent-sdk>=2.0.0"
  },
  "limits": {
    "maxTokens": 200000,
    "rateLimit": "50/min"
  }
}
```

---

## 8. Безопасность

### 8.1. Авторизация
- **Токены**: JWT с коротким сроком действия (24h default)
- **TOTP**: Опциональная двухфакторная аутентификация для удалённого доступа
- **Refresh tokens**: Автоматическое обновление токенов без повторной авторизации

### 8.2. Изоляция данных
- Каждый провайдер получает изолированный namespace в `~/.codeai-hub/providers/<providerId>/`
- Модули не имеют доступа к данным других провайдеров
- Секреты хранятся в системном keychain с уникальными ключами

### 8.3. Сетевая безопасность
- По умолчанию bind к `127.0.0.1` (только локальные подключения)
- HTTPS опционально для удалённого доступа
- Rate limiting на уровне API (100 req/min per client)
- WebSocket ping/pong для обнаружения мёртвых соединений

### 8.4. Аудит
- Все критичные операции логируются (авторизация, создание сессий, доступ к секретам)
- Логи включают clientId, timestamp, action, result
- Возможность экспорта аудит-логов для анализа

---

## 9. Производительность

### 9.1. Требования
- **Latency**: WebSocket сообщения < 50ms
- **Throughput**: 100+ одновременных подключений
- **Memory**: < 500MB RAM для 10 активных сессий
- **Startup**: < 3 секунды холодный старт

### 9.2. Оптимизации
- Lazy loading провайдерных модулей
- Cold storage для неактивных сессий (выгрузка из памяти после 1h простоя)
- Connection pooling для провайдеров
- Streaming без буферизации (прямая передача в WebSocket)

### 9.3. Метрики
- Время обработки запросов (p50, p95, p99)
- Использование памяти по модулям
- Количество активных WebSocket подключений
- Rate limit hits по провайдерам

---

## 10. Обработка ошибок

### 10.1. Категории ошибок
- **Recoverable**: Временные сбои (сеть, rate limits) → автоматический retry
- **User action required**: Истечение токенов, квоты → уведомление пользователю
- **Fatal**: Критические ошибки (нехватка памяти, повреждение данных) → graceful shutdown

### 10.2. Стратегии восстановления
- **Exponential backoff**: Для сетевых ошибок (1s, 2s, 4s, max 60s)
- **Circuit breaker**: Отключение проблемного провайдера на 5 минут после 5 ошибок подряд
- **Fallback**: Автоматическое переключение на резервного провайдера (если настроено)
- **Graceful degradation**: Продолжение работы других сессий при падении одной

### 10.3. Уведомления клиентов
Все ошибки отправляются клиентам в унифицированном формате:
```json
{
  "type": "error",
  "code": "PROVIDER_RATE_LIMIT",
  "message": "Claude API rate limit exceeded",
  "recoverable": true,
  "retryAfter": 60,
  "actions": [
    { "id": "switch_provider", "label": "Switch to Codex" },
    { "id": "retry", "label": "Retry in 1 minute" }
  ]
}
```

---

## 11. Зависимости и интеграции

### 11.1. Внутренние зависимости
- Node.js >= 20.0.0
- TypeScript >= 5.3
- express (HTTP server)
- ws (WebSocket)
- uuid (генерация ID)
- winston (логирование)
- keytar (системный keychain)

### 11.2. Внешние интеграции
- **Провайдерные CLI/SDK**: Скачиваются и устанавливаются автоматически
- **GitHub Releases**: Для скачивания бинарников ядра и провайдерных модулей (URL и версии определяются манифестами внутри VSIX)
- **System Keychain**: macOS Keychain, Windows Credential Manager, Linux Secret Service

### 11.3. Платформенные требования
- **macOS**: 10.15+ (Keychain Access API)
- **Windows**: 10+ (Credential Manager API)
- **Linux**: GNOME Keyring или KWallet

---

## 12. Жизненный цикл и развёртывание

### 12.1. Установка
1. При первой активации расширение читает манифест `assets/core/manifest.json` внутри VSIX
2. Скачивает бинарник ядра по URL из манифеста (GitHub Releases)
3. Распаковывает в `~/.codeai-hub/core/<version>/`
4. Выполняет `npm install --production` (или использует prebundled node_modules)
5. Создаёт начальную конфигурацию
6. Запускает процесс ядра

> **Важно**: Все URL и версии контролируются через манифесты внутри VSIX. Это избегает необходимости code signing и developer accounts.

### 12.2. Обновление
1. Пользователь обновляет VSIX из VS Code Marketplace
2. При активации расширение сравнивает версию ядра из нового манифеста с установленной
3. При несовпадении версий скачивает новое ядро по URL из обновлённого манифеста
4. Предлагает пользователю перезапустить ядро
5. При подтверждении:
   - Отправляет команду `CodeAI Hub: Restart Core`
   - Ждёт завершения активных операций (grace period 1 минута)
   - Останавливает старый процесс
   - Запускает новый процесс из `~/.codeai-hub/core/<новая_версия>/`
   - Клиенты переподключаются автоматически

> **Важно**: Обновление ядра возможно **только через обновление VSIX**. Автономное обновление ядра не поддерживается.

### 12.3. Откат
Если новая версия не запускается:
1. Расширение обнаруживает ошибку запуска (timeout 10s)
2. Автоматически откатывается на предыдущую версию
3. Уведомляет пользователя о проблеме
4. Создаёт diagnostic report в `~/.codeai-hub/logs/crash-<timestamp>.json`

### 12.4. Удаление
Команда `CodeAI Hub: Uninstall Core`:
1. Останавливает процесс ядра
2. Предлагает сохранить данные сессий (backup)
3. Удаляет `~/.codeai-hub/core/`
4. Опционально удаляет все данные (`~/.codeai-hub/`)

---

## 13. Тестирование

### 13.1. Unit тесты
- Каждый модуль должен иметь покрытие >= 80%
- Моки для внешних зависимостей (провайдеры, keychain, файловая система)

### 13.2. Integration тесты
- Запуск полного цикла: start → create session → send message → stream response → stop
- Тестирование переподключений WebSocket
- Проверка персистентности после рестарта

### 13.3. E2E тесты
- Запуск с реальными клиентами (VS Code webview, CEF)
- Проверка синхронизации между клиентами
- Тестирование обновлений

### 13.4. Performance тесты
- Load testing: 100+ одновременных подключений
- Stress testing: 1000+ сообщений в минуту
- Memory leak detection

---

## 14. Метрики успеха (Definition of Done для Phase 14)

### 14.1. Функциональные критерии
- ✅ Ядро запускается автоматически при активации расширения
- ✅ VS Code webview подключается к ядру через WebSocket
- ✅ CEF-клиент подключается к тому же ядру
- ✅ Создание сессии с mock-провайдером работает
- ✅ Отправка сообщения и получение mock-ответа работает
- ✅ Синхронизация состояния между webview и CEF работает
- ✅ Ядро продолжает работать после закрытия VS Code
- ✅ Восстановление сессий после перезапуска ядра работает

### 14.2. Нефункциональные критерии
- ✅ Startup time < 5s
- ✅ Memory usage < 500MB для 10 сессий
- ✅ WebSocket latency < 100ms (локальное подключение)
- ✅ Нет memory leaks при длительной работе (24h+)

### 14.3. Качество кода
- ✅ TypeScript без `any` (кроме edge cases)
- ✅ Ultracite (Biome) проходит без ошибок
- ✅ Unit тесты покрытие >= 80%
- ✅ Документация API полная (JSDoc)

---

## 15. Открытые вопросы (для обсуждения)

### 15.1. Архитектурные решения
- **Q1**: Использовать ли встроенную SQLite для персистентности или продолжить с JSONL?
  - **Плюсы SQLite**: Быстрые запросы, индексы, транзакции
  - **Плюсы JSONL**: Простота, читаемость, git-friendly
  - **Предложение**: JSONL для MVP, SQLite для оптимизации позже

- **Q2**: Как упаковывать ядро — pkg (single binary) или distributable node_modules?
  - **pkg**: Один исполняемый файл, проще установка, больше размер (~45MB)
  - **node_modules**: Меньше размер, сложнее установка, требует Node.js
  - **Предложение**: pkg для кросс-платформенности

### 15.2. Функциональность
- **Q3**: Поддержка мультипользовательского режима (несколько пользователей на одной машине)?
  - **Сложность**: Изоляция данных, отдельные порты, управление доступом
  - **Предложение**: Отложить на будущее, пока не востребовано

- **Q4**: Механизм плагинов для расширения функциональности ядра?
  - **Примеры**: Custom визарды, интеграции с внешними сервисами
  - **Предложение**: Заложить архитектуру, реализация после MVP

- **Q5**: Уровень изоляции провайдеров — процессы или просто модули?
  - **Процессы**: Полная изоляция, защита от падений, больше overhead
  - **Модули**: Проще, быстрее, меньше защиты
  - **Предложение**: Модули для MVP, процессы при необходимости

### 15.3. Безопасность
> **Решено**: Для локальных подключений (VS Code, CEF-клиент) авторизация НЕ требуется. Ядро bind только на `127.0.0.1`. Авторизация, HTTPS, TOTP будут реализованы только для удалённого доступа (перспективная функция).

### 15.4. Производительность
- **Q6**: Лимиты на количество сессий/клиентов?
  - **Предложение**: 10 активных сессий, 5 одновременных клиентов (настраивается)

- **Q7**: Стратегия кэширования ответов провайдеров?
  - **Потенциал**: Экономия токенов для повторяющихся запросов
  - **Риски**: Устаревшие данные, усложнение логики
  - **Предложение**: Отложить, оценить после реальной эксплуатации

---

## 16. Roadmap

### Phase 10 ✅ (Завершена)
- Создание структуры packages/core/
- Настройка npm workspaces и инструментов сборки
- Создание манифестов и установщика

### Phase 10А 🔄 (Текущая)
- Создание данной спецификации
- Обсуждение с пользователем
- Согласование архитектурных решений

### Phase 11 📋 (Следующая)
- Детальное проектирование модулей
- Создание Mermaid-диаграмм взаимодействия
- Определение всех интерфейсов и контрактов
- Обновление Architecture.md

### Phase 12
- Реализация точки входа и базового запуска
- Создание заглушек всех модулей
- Базовый HTTP server с health check
- Тестирование ручного запуска

### Phase 13
- Реализация WebSocket hub
- Токен-авторизация
- Подключение VS Code webview
- Подключение CEF-клиента

### Phase 14
- Mock-провайдеры для тестирования
- Интеграционное тестирование полного цикла
- Проверка синхронизации между клиентами
- Сборка релиза и документация

---

## 17. Справочная информация

### 17.1. Связанные документы
- `doc/Architecture/Architecture.md`
- `doc/Project_Docs/SystemArchitecture/SystemArchitecture.md`
- `doc/Project_Docs/Stacks/CEF_DeliveryPlan.md`
- `doc/TODO/todo-plan.md`

### 17.2. Внешние ресурсы
- [Node.js Documentation](https://nodejs.org/docs/)
- [WebSocket Protocol RFC 6455](https://tools.ietf.org/html/rfc6455)
- [JWT RFC 7519](https://tools.ietf.org/html/rfc7519)
- [TOTP RFC 6238](https://tools.ietf.org/html/rfc6238)

### 17.3. История изменений
- **2025-10-24 v0.1.0-draft**: Первая версия спецификации (Phase 10А)
- **2025-10-24 v0.1.1-draft**: Обновлена логика жизненного цикла ядра:
  - Ядро запускается при подключении первого клиента
  - Ядро работает пока есть хотя бы один подключенный клиент
  - Grace period 1 минута после отключения последнего клиента
  - Удалено требование F-10 про cold storage
  - Удален вопрос Q3 про автозапуск при старте системы
  - Обновлен User Journey 2.2 с детализацией shutdown логики
  - Перенумерованы функциональные требования (F-01 до F-35)
  - Перенумерованы открытые вопросы (Q1 до Q9)
- **2025-10-24 v0.1.2-draft**: Уточнена логика управления сессиями и добавлен Provider Event Adapter:
  - Раздел 3.2: Разделены текущие (F-08) и перспективные требования (F-09 до F-12)
  - Для обычных сессий персистентность, resume, экспорт обеспечивают сами провайдеры
  - Требования F-09 до F-12 относятся только к комбинированным сессиям (несколько провайдеров)
  - Добавлено требование F-19: Provider Event Adapter для унификации событий от всех провайдеров
  - Добавлен модуль event-adapter/ в структуру packages/core/
  - Добавлен раздел 4.5: Provider Event Adapter с полным описанием интерфейсов
  - Уточнены команды F-06 и F-07: явно указано что это команды VS Code расширения
  - Перенумерованы функциональные требования (F-01 до F-36)
- **2025-10-24 v0.1.3-draft**: Уточнена стратегия обновлений:
  - Раздел 1.3: Обновление ядра возможно **только через обновление VSIX** (избегаем code signing)
  - Раздел 11.2: Уточнено что URL и версии определяются манифестами внутри VSIX
  - Раздел 12.1: Детализирован процесс установки через манифест assets/core/manifest.json
  - Раздел 12.2: Уточнено что обновление триггерится обновлением VSIX из Marketplace
  - Добавлены важные примечания про отсутствие автономного обновления ядра
- **2025-10-24 v0.1.4-draft**: Убрана авторизация для локальных подключений:
  - Раздел 2.1: Убрано создание токена авторизации, добавлено что ядро bind на `127.0.0.1:8080`
  - Раздел 2.5: Добавлено примечание что удалённый доступ — перспективная функция (не для MVP)
  - Раздел 3.4: Разделены текущие требования (F-20 до F-23) и перспективные (F-24 до F-27)
  - Для локальных подключений авторизация НЕ требуется, ядро bind только на `127.0.0.1`
  - Авторизация (JWT), HTTPS, TOTP отнесены к перспективным требованиям для удалённого доступа
  - Раздел 15.3: Убраны вопросы Q6 и Q7 про авторизацию локальных подключений (решение принято)
  - Перенумерованы функциональные требования (F-01 до F-37)
  - Перенумерованы открытые вопросы (Q1 до Q7)
- **2025-10-24 v0.1.5-draft**: Упрощён User Journey первой установки и добавлена логика выбора провайдеров:
  - Раздел 2.1: Переработан сценарий первой установки (шаги 1-9)
  - Подключение к ядру происходит "тихо" с timeout 15 секунд
  - При успешном подключении — UI готов без уведомлений
  - При ошибке — показывается диагностическое сообщение
  - Добавлено описание механизма "New Session" → выбор провайдера из списка
  - Добавлено описание Settings → отключение провайдеров из списка выбора
  - Добавлено требование F-20: Ядро предоставляет список подключённых провайдеров для UI
  - Перенумерованы функциональные требования (F-01 до F-38)
- **2025-10-24 v0.1.6-draft**: Добавлен архитектурный принцип "UI as View" и детальная синхронизация:
  - Раздел 1.2: Добавлен принцип "single source of truth" — ядро хранит ВСЁ, UI только отображают
  - Раздел 2.2: Полностью переработан User Journey с демонстрацией синхронизации между webview и CEF-клиентом (18 шагов)
  - Показана синхронизация: сессий, сообщений, настроек, списка провайдеров
  - Раздел 3.4: Расширены требования F-24, F-25, F-26 с детальным описанием синхронизации
  - **F-24**: Синхронизация ВСЁ состояния (сессии, сообщения, настройки, провайдеры, состояние UI)
  - **F-25**: UI НЕ хранят данные локально — stateless view
  - **F-26**: Initial state sync при подключении нового клиента
  - Добавлен архитектурный принцип: "Ядро — единственный источник правды, UI — stateless view"
  - Перенумерованы функциональные требования (F-01 до F-40)

---

## Заключение

Данный документ является рабочим черновиком и будет дополнен после обсуждения с пользователем. Все открытые вопросы требуют принятия решений перед переходом к Phase 11 (проектирование).

**Следующие шаги**:
1. Обсудить архитектурные решения (раздел 15)
2. Согласовать user journeys и приоритеты
3. Уточнить требования к производительности
4. Принять решения по безопасности
5. Обновить спецификацию и перейти к Phase 11
