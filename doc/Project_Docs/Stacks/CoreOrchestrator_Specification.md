# Спецификация автономного ядра CodeAI-Hub (Core Orchestrator)

**Версия:** 0.1.0-draft  
**Дата:** 2025-10-24  
**Статус:** Черновик для обсуждения  
**Фаза:** Phase 10А

---

## 1. Обзор и назначение

### 1.1. Цель документа
Данная спецификация описывает функциональные и нефункциональные требования к автономному ядру CodeAI-Hub (Core Orchestrator), его архитектуру, API, контракты взаимодействия и жизненный цикл. Документ является основой для проектирования (Phase 11) и реализации (Phase 12-14) ядра.

### 1.2. Что такое Core Orchestrator
Core Orchestrator — это автономный Node.js-сервис, который:
- Работает независимо от VS Code и других клиентов
- Управляет жизненным циклом AI-сессий
- Обеспечивает единую точку интеграции с провайдерами (Claude, Codex, Gemini)
- Предоставляет HTTP/WebSocket API для подключения множественных клиентов
- Автоматически устанавливает и обновляет провайдерные модули
- Персистирует данные сессий и конфигурацию
- Продолжает работу после закрытия клиентских приложений

### 1.3. Проблемы, которые решает ядро
- **Дублирование логики**: без ядра каждый клиент (VS Code, CEF, mobile) должен реализовывать логику провайдеров независимо
- **Размер VSIX**: встраивание всех зависимостей увеличивает размер расширения и усложняет обновления
- **Мультисессионность**: сложно синхронизировать состояние между разными клиентами без центрального сервиса
- **Обновления**: автономное ядро можно обновлять без переустановки расширения
- **Персистентность**: сессии переживают перезапуск клиентов и VS Code

---

## 2. Пользовательские сценарии (User Journeys)

### 2.1. Первая установка и запуск
**Актор**: Пользователь, впервые устанавливающий расширение

1. Пользователь устанавливает VSIX из VS Code Marketplace
2. При первой активации расширение:
   - Скачивает автономное ядро из публичного репозитория в `~/.codeai-hub/core/<version>/`
   - Устанавливает зависимости ядра (express, ws и др.)
   - Генерирует начальную конфигурацию `config.json`
   - Запускает процесс ядра в фоновом режиме
   - Создаёт токен авторизации для расширения
3. Расширение подключается к ядру через WebSocket
4. В webview отображается приветственный экран с выбором провайдера
5. Пользователь выбирает провайдера (например, Claude)
6. Ядро проверяет наличие модуля Claude, скачивает его при необходимости
7. Модуль Claude запрашивает авторизацию пользователя
8. После авторизации пользователь может создать первую сессию

**Ожидаемый результат**: Пользователь готов к работе без ручной настройки

### 2.2. Ежедневная работа с сессиями
**Актор**: Пользователь, работающий с несколькими AI-сессиями

1. Пользователь открывает VS Code
2. Расширение автоматически подключается к уже запущенному ядру
3. В webview восстанавливаются активные сессии из предыдущего сеанса
4. Пользователь создаёт новую сессию с провайдером Codex
5. Параллельно открывает локальный CEF-клиент
6. CEF-клиент подключается к тому же ядру и отображает те же сессии
7. Пользователь отправляет сообщение в webview, оно мгновенно отображается в CEF-клиенте
8. Пользователь закрывает VS Code, но CEF-клиент продолжает работать
9. Сессии остаются активными, диалоги продолжаются
10. На следующий день пользователь снова открывает VS Code и видит все сессии

**Ожидаемый результат**: Непрерывность работы независимо от клиентов

### 2.3. Обновление системы
**Актор**: Пользователь, у которого выходит новая версия расширения

1. VS Code уведомляет о доступном обновлении расширения
2. Пользователь обновляет VSIX
3. При активации расширение проверяет версию ядра
4. Обнаруживается несоответствие версий
5. Расширение скачивает новую версию ядра параллельно с работой старой
6. После скачивания предлагает пользователю перезапустить ядро
7. Пользователь подтверждает
8. Ядро корректно завершает текущие операции
9. Все подключённые клиенты получают уведомление `core:restarting`
10. Запускается новая версия ядра
11. Клиенты переподключаются автоматически
12. Все сессии восстанавливаются из персистентного хранилища

**Ожидаемый результат**: Бесшовное обновление с минимальным downtime

### 2.4. Работа с несколькими провайдерами
**Актор**: Пользователь, использующий Claude и Codex одновременно

1. Пользователь создаёт сессию с Claude для code review
2. В параллельной сессии использует Codex для генерации кода
3. Claude достигает rate limit
4. Ядро уведомляет пользователя и предлагает переключиться на резервного провайдера
5. Пользователь переключает сессию на Gemini
6. Контекст диалога сохраняется, работа продолжается
7. В настройках пользователь просматривает статистику использования по провайдерам
8. Видит оставшиеся квоты и время их обновления

**Ожидаемый результат**: Гибкое переключение провайдеров без потери контекста

### 2.5. Удалённый доступ (будущая функция)
**Актор**: Пользователь, работающий с планшета

1. Пользователь настраивает Remote UI Bridge на своём компьютере
2. Включает HTTPS и TOTP-аутентификацию
3. На планшете открывает веб-интерфейс по адресу `https://my-machine.local:8443`
4. Вводит TOTP-код из Google Authenticator
5. Получает короткоживущий токен и подключается к ядру
6. Видит все свои сессии, может создавать новые
7. Отправляет сообщения, получает ответы в реальном времени
8. При потере соединения интерфейс автоматически переподключается

**Ожидаемый результат**: Доступ к сессиям с любого устройства

---

## 3. Функциональные требования

### 3.1. Управление жизненным циклом
- **F-01**: Ядро должно запускаться как фоновый процесс при активации расширения
- **F-02**: Ядро должно продолжать работу после закрытия клиентов
- **F-03**: Ядро должно корректно завершаться по команде `shutdown` с сохранением состояния
- **F-04**: Ядро должно поддерживать graceful restart с уведомлением клиентов
- **F-05**: Ядро должно восстанавливать сессии после перезапуска

### 3.2. Управление сессиями
- **F-06**: Ядро должно поддерживать множественные одновременные сессии
- **F-07**: Каждая сессия должна иметь уникальный идентификатор (UUID)
- **F-08**: Ядро должно персистировать историю диалогов в JSONL-формате
- **F-09**: Ядро должно поддерживать pause/resume сессий
- **F-10**: Ядро должно автоматически выгружать неактивные сессии (cold storage)
- **F-11**: Ядро должно поддерживать экспорт/импорт сессий

### 3.3. Управление провайдерами
- **F-12**: Ядро должно динамически загружать провайдерные модули
- **F-13**: Ядро должно проверять совместимость версий модулей
- **F-14**: Ядро должно автоматически устанавливать CLI/SDK провайдеров
- **F-15**: Ядро должно обновлять провайдеры без остановки других сессий
- **F-16**: Ядро должно изолировать данные разных провайдеров
- **F-17**: Ядро должно отслеживать квоты и лимиты провайдеров

### 3.4. Remote UI Bridge
- **F-18**: Ядро должно предоставлять HTTP API для управления (health check, status, config)
- **F-19**: Ядро должно предоставлять WebSocket API для real-time коммуникации
- **F-20**: Ядро должно поддерживать авторизацию по токенам
- **F-21**: Ядро должно поддерживать множественные одновременные подключения
- **F-22**: Ядро должно синхронизировать состояние между всеми клиентами
- **F-23**: Ядро должно поддерживать HTTPS (опционально)
- **F-24**: Ядро должно поддерживать TOTP-аутентификацию (опционально)

### 3.5. Конфигурация и хранилище
- **F-25**: Ядро должно читать конфигурацию из `~/.codeai-hub/core/config.json`
- **F-26**: Ядро должно сохранять секреты в системном keychain
- **F-27**: Ядро должно поддерживать горячую перезагрузку конфигурации
- **F-28**: Ядро должно версионировать схему конфигурации
- **F-29**: Ядро должно создавать резервные копии данных

### 3.6. Логирование и диагностика
- **F-30**: Ядро должно вести структурированные логи в `~/.codeai-hub/logs/`
- **F-31**: Ядро должны поддерживать уровни логирования (debug, info, warn, error)
- **F-32**: Ядро должно ротировать логи по размеру/времени
- **F-33**: Ядро должно экспортировать диагностические данные по запросу
- **F-34**: Ядро должно собирать метрики производительности (опционально)

---

## 4. Архитектурные компоненты

### 4.1. Структура модулей

```
packages/core/
├── src/
│   ├── index.ts                    # Точка входа
│   ├── orchestrator/               # Core Orchestrator
│   │   ├── orchestrator.ts         # Главный координатор
│   │   ├── lifecycle-manager.ts    # Управление запуском/остановкой
│   │   └── event-router.ts         # Маршрутизация событий
│   ├── session-manager/            # Session Manager
│   │   ├── session-manager.ts      # Управление сессиями
│   │   ├── session-store.ts        # Персистентность сессий
│   │   └── session-context.ts      # Контекст сессии
│   ├── provider-registry/          # Provider Registry
│   │   ├── registry.ts             # Реестр провайдеров
│   │   ├── loader.ts               # Загрузка модулей
│   │   └── adapter.ts              # Адаптеры провайдеров
│   ├── remote-bridge/              # Remote UI Bridge
│   │   ├── http-server.ts          # HTTP API
│   │   ├── websocket-hub.ts        # WebSocket hub
│   │   ├── auth-middleware.ts      # Авторизация
│   │   └── message-validator.ts    # Валидация сообщений
│   ├── config/                     # Configuration
│   │   ├── config-loader.ts        # Загрузка конфигурации
│   │   ├── secrets-manager.ts      # Управление секретами
│   │   └── schema.ts               # Схемы конфигурации
│   └── telemetry/                  # Telemetry & Logging
│       ├── logger.ts               # Структурированное логирование
│       ├── metrics.ts              # Сбор метрик
│       └── diagnostics.ts          # Диагностика
├── package.json
└── tsconfig.json
```

### 4.2. Core Orchestrator
**Ответственность**: Центральная координация всех компонентов

**Основные функции**:
- Инициализация и остановка всех модулей
- Маршрутизация событий между компонентами
- Управление жизненным циклом сервиса
- Координация провайдеров и сессий

**Интерфейсы**:
```typescript
interface ICoreOrchestrator {
  start(): Promise<void>;
  stop(): Promise<void>;
  restart(): Promise<void>;
  getStatus(): OrchestratorStatus;
  on(event: string, handler: Function): void;
  emit(event: string, data: any): void;
}
```

### 4.3. Session Manager
**Ответственность**: Управление жизненным циклом сессий

**Основные функции**:
- Создание, приостановка, возобновление, удаление сессий
- Персистентность диалогов в JSONL
- Управление контекстом сессий
- Выгрузка холодных сессий

**Интерфейсы**:
```typescript
interface ISessionManager {
  createSession(request: CreateSessionRequest): Promise<Session>;
  getSession(sessionId: string): Promise<Session | null>;
  pauseSession(sessionId: string): Promise<void>;
  resumeSession(sessionId: string): Promise<void>;
  deleteSession(sessionId: string): Promise<void>;
  listSessions(filter?: SessionFilter): Promise<Session[]>;
  persistSession(session: Session): Promise<void>;
}
```

### 4.4. Provider Registry
**Ответственность**: Управление провайдерными модулями

**Основные функции**:
- Регистрация и деактивация провайдеров
- Загрузка модулей из публичных источников
- Проверка версий и совместимости
- Изоляция данных провайдеров

**Интерфейсы**:
```typescript
interface IProviderRegistry {
  registerProvider(provider: ProviderModule): void;
  unregisterProvider(providerId: string): void;
  getProvider(providerId: string): ProviderModule | null;
  listProviders(): ProviderMetadata[];
  installProvider(providerId: string): Promise<void>;
  updateProvider(providerId: string): Promise<void>;
  getCapabilities(providerId: string): ProviderCapabilities;
}
```

### 4.5. Remote UI Bridge
**Ответственность**: API для подключения клиентов

**Основные функции**:
- HTTP API для управления (GET /health, POST /sessions, etc.)
- WebSocket для real-time событий
- Авторизация по токенам
- Синхронизация состояния между клиентами

**Интерфейсы**:
```typescript
interface IRemoteBridge {
  startServer(config: ServerConfig): Promise<void>;
  stopServer(): Promise<void>;
  authenticateClient(token: string): Promise<ClientSession>;
  broadcast(event: BridgeEvent): void;
  sendToClient(clientId: string, event: BridgeEvent): void;
}
```

### 4.6. Config & Secrets Manager
**Ответственность**: Управление конфигурацией и секретами

**Основные функции**:
- Загрузка конфигурации из файла
- Горячая перезагрузка настроек
- Сохранение секретов в системном keychain
- Валидация схемы конфигурации

**Интерфейсы**:
```typescript
interface IConfigManager {
  load(): Promise<CoreConfig>;
  reload(): Promise<void>;
  get<T>(key: string): T;
  set(key: string, value: any): Promise<void>;
}

interface ISecretsManager {
  setSecret(key: string, value: string): Promise<void>;
  getSecret(key: string): Promise<string | null>;
  deleteSecret(key: string): Promise<void>;
}
```

### 4.7. Telemetry & Logging
**Ответственность**: Логирование и диагностика

**Основные функции**:
- Структурированное логирование (JSON)
- Ротация логов
- Сбор метрик производительности
- Экспорт диагностических данных

**Интерфейсы**:
```typescript
interface ILogger {
  debug(message: string, context?: object): void;
  info(message: string, context?: object): void;
  warn(message: string, context?: object): void;
  error(message: string, error: Error, context?: object): void;
}
```

---

## 5. API спецификация

### 5.1. HTTP API

#### 5.1.1. Health Check
```http
GET /api/v1/health
```
**Response**:
```json
{
  "status": "ok",
  "version": "0.1.0",
  "uptime": 3600,
  "activeSessions": 5
}
```

#### 5.1.2. Get Status
```http
GET /api/v1/status
Authorization: Bearer <token>
```
**Response**:
```json
{
  "core": {
    "version": "0.1.0",
    "uptime": 3600,
    "pid": 12345
  },
  "providers": [
    {
      "id": "claude",
      "version": "1.22.0",
      "status": "active",
      "sessions": 2
    }
  ],
  "sessions": [
    {
      "id": "sess-123",
      "providerId": "claude",
      "status": "active",
      "createdAt": "2025-10-24T10:00:00Z"
    }
  ]
}
```

#### 5.1.3. Create Session
```http
POST /api/v1/sessions
Authorization: Bearer <token>
Content-Type: application/json

{
  "providerId": "claude",
  "settings": {
    "model": "claude-sonnet-4",
    "streaming": true
  }
}
```
**Response**:
```json
{
  "sessionId": "sess-456",
  "status": "created",
  "wsUrl": "ws://localhost:8080/api/v1/sessions/sess-456/stream"
}
```

#### 5.1.4. Get Session
```http
GET /api/v1/sessions/{sessionId}
Authorization: Bearer <token>
```

#### 5.1.5. Delete Session
```http
DELETE /api/v1/sessions/{sessionId}
Authorization: Bearer <token>
```

#### 5.1.6. List Providers
```http
GET /api/v1/providers
Authorization: Bearer <token>
```

#### 5.1.7. Shutdown Core
```http
POST /api/v1/core/shutdown
Authorization: Bearer <token>
```

### 5.2. WebSocket API

#### 5.2.1. Подключение
```javascript
const ws = new WebSocket('ws://localhost:8080/api/v1/stream?token=<token>');
```

#### 5.2.2. Формат сообщений

**Client → Server**:
```json
{
  "type": "session:create" | "session:message" | "session:stop",
  "sessionId": "sess-123",
  "payload": { ... }
}
```

**Server → Client**:
```json
{
  "type": "session:update" | "stream:chunk" | "workflow:event" | "error",
  "sessionId": "sess-123",
  "payload": { ... },
  "timestamp": "2025-10-24T10:00:00Z"
}
```

#### 5.2.3. Типы событий

**`session:update`** - обновление состояния сессии:
```json
{
  "type": "session:update",
  "sessionId": "sess-123",
  "payload": {
    "status": "active" | "paused" | "stopped",
    "messageCount": 10
  }
}
```

**`stream:chunk`** - потоковый вывод от провайдера:
```json
{
  "type": "stream:chunk",
  "sessionId": "sess-123",
  "payload": {
    "role": "assistant",
    "content": "Hello world",
    "delta": true
  }
}
```

**`workflow:event`** - системные события:
```json
{
  "type": "workflow:event",
  "payload": {
    "event": "provider:quota_warning",
    "providerId": "claude",
    "remaining": 100
  }
}
```

**`error`** - ошибки:
```json
{
  "type": "error",
  "sessionId": "sess-123",
  "payload": {
    "code": "PROVIDER_ERROR",
    "message": "Claude API rate limit exceeded",
    "recoverable": true,
    "actions": ["switch_provider", "retry_later"]
  }
}
```

---

## 6. Контракты провайдеров

### 6.1. Интерфейс провайдерного модуля
```typescript
interface IProviderModule {
  // Метаданные
  id: string;
  name: string;
  version: string;
  
  // Жизненный цикл
  installOrUpdate(context: InstallContext): Promise<InstallResult>;
  configure(settings: ProviderSettings): Promise<void>;
  
  // Сессии
  startSession(request: StartSessionRequest): Promise<SessionDescriptor>;
  stopSession(sessionId: string): Promise<void>;
  
  // Потоковая передача
  streamEvents(sessionId: string): AsyncIterator<ProviderEvent>;
  
  // Возможности
  getCapabilities(): ProviderCapabilities;
}
```

### 6.2. Адаптеры событий
Каждый провайдер должен преобразовывать свои события в унифицированный формат:

```typescript
type UnifiedEvent =
  | { type: 'message', role: 'user' | 'assistant', content: string }
  | { type: 'tool_call', name: string, args: object }
  | { type: 'tool_result', callId: string, result: any }
  | { type: 'status', status: string, message?: string }
  | { type: 'thinking', content: string }
  | { type: 'error', error: Error };
```

---

## 7. Схемы данных

### 7.1. Конфигурация ядра
```json
{
  "version": "0.1.0",
  "core": {
    "port": 8080,
    "host": "127.0.0.1",
    "logLevel": "info",
    "dataDir": "~/.codeai-hub"
  },
  "bridge": {
    "enabled": true,
    "https": false,
    "auth": {
      "type": "token",
      "tokenExpiry": 86400
    }
  },
  "providers": {
    "autoUpdate": true,
    "checkInterval": 3600
  },
  "sessions": {
    "maxConcurrent": 10,
    "coldStorageTimeout": 3600,
    "persistenceFormat": "jsonl"
  }
}
```

### 7.2. Session Schema
```json
{
  "id": "sess-123",
  "providerId": "claude",
  "status": "active",
  "createdAt": "2025-10-24T10:00:00Z",
  "updatedAt": "2025-10-24T10:30:00Z",
  "messages": [
    {
      "id": "msg-1",
      "role": "user",
      "content": "Hello",
      "timestamp": "2025-10-24T10:00:00Z"
    }
  ],
  "metadata": {
    "title": "Code Review Session",
    "tags": ["review", "typescript"]
  }
}
```

### 7.3. Provider Metadata
```json
{
  "id": "claude",
  "name": "Anthropic Claude",
  "version": "1.22.0",
  "capabilities": {
    "streaming": true,
    "toolUse": true,
    "fileOps": true,
    "thinking": true
  },
  "dependencies": {
    "cli": "claude-code>=1.22.0",
    "sdk": "@anthropic-ai/claude-agent-sdk>=2.0.0"
  },
  "limits": {
    "maxTokens": 200000,
    "rateLimit": "50/min"
  }
}
```

---

## 8. Безопасность

### 8.1. Авторизация
- **Токены**: JWT с коротким сроком действия (24h default)
- **TOTP**: Опциональная двухфакторная аутентификация для удалённого доступа
- **Refresh tokens**: Автоматическое обновление токенов без повторной авторизации

### 8.2. Изоляция данных
- Каждый провайдер получает изолированный namespace в `~/.codeai-hub/providers/<providerId>/`
- Модули не имеют доступа к данным других провайдеров
- Секреты хранятся в системном keychain с уникальными ключами

### 8.3. Сетевая безопасность
- По умолчанию bind к `127.0.0.1` (только локальные подключения)
- HTTPS опционально для удалённого доступа
- Rate limiting на уровне API (100 req/min per client)
- WebSocket ping/pong для обнаружения мёртвых соединений

### 8.4. Аудит
- Все критичные операции логируются (авторизация, создание сессий, доступ к секретам)
- Логи включают clientId, timestamp, action, result
- Возможность экспорта аудит-логов для анализа

---

## 9. Производительность

### 9.1. Требования
- **Latency**: WebSocket сообщения < 50ms
- **Throughput**: 100+ одновременных подключений
- **Memory**: < 500MB RAM для 10 активных сессий
- **Startup**: < 3 секунды холодный старт

### 9.2. Оптимизации
- Lazy loading провайдерных модулей
- Cold storage для неактивных сессий (выгрузка из памяти после 1h простоя)
- Connection pooling для провайдеров
- Streaming без буферизации (прямая передача в WebSocket)

### 9.3. Метрики
- Время обработки запросов (p50, p95, p99)
- Использование памяти по модулям
- Количество активных WebSocket подключений
- Rate limit hits по провайдерам

---

## 10. Обработка ошибок

### 10.1. Категории ошибок
- **Recoverable**: Временные сбои (сеть, rate limits) → автоматический retry
- **User action required**: Истечение токенов, квоты → уведомление пользователю
- **Fatal**: Критические ошибки (нехватка памяти, повреждение данных) → graceful shutdown

### 10.2. Стратегии восстановления
- **Exponential backoff**: Для сетевых ошибок (1s, 2s, 4s, max 60s)
- **Circuit breaker**: Отключение проблемного провайдера на 5 минут после 5 ошибок подряд
- **Fallback**: Автоматическое переключение на резервного провайдера (если настроено)
- **Graceful degradation**: Продолжение работы других сессий при падении одной

### 10.3. Уведомления клиентов
Все ошибки отправляются клиентам в унифицированном формате:
```json
{
  "type": "error",
  "code": "PROVIDER_RATE_LIMIT",
  "message": "Claude API rate limit exceeded",
  "recoverable": true,
  "retryAfter": 60,
  "actions": [
    { "id": "switch_provider", "label": "Switch to Codex" },
    { "id": "retry", "label": "Retry in 1 minute" }
  ]
}
```

---

## 11. Зависимости и интеграции

### 11.1. Внутренние зависимости
- Node.js >= 20.0.0
- TypeScript >= 5.3
- express (HTTP server)
- ws (WebSocket)
- uuid (генерация ID)
- winston (логирование)
- keytar (системный keychain)

### 11.2. Внешние интеграции
- **Провайдерные CLI/SDK**: Скачиваются и устанавливаются автоматически
- **GitHub Releases**: Для скачивания модулей и обновлений
- **System Keychain**: macOS Keychain, Windows Credential Manager, Linux Secret Service

### 11.3. Платформенные требования
- **macOS**: 10.15+ (Keychain Access API)
- **Windows**: 10+ (Credential Manager API)
- **Linux**: GNOME Keyring или KWallet

---

## 12. Жизненный цикл и развёртывание

### 12.1. Установка
1. Расширение скачивает бинарник ядра из GitHub Releases
2. Распаковывает в `~/.codeai-hub/core/<version>/`
3. Выполняет `npm install --production` (или использует prebundled node_modules)
4. Создаёт начальную конфигурацию
5. Запускает процесс ядра
6. Регистрирует автозапуск (опционально)

### 12.2. Обновление
1. Расширение проверяет `core/manifest.json` при активации
2. При несовпадении версий скачивает новое ядро параллельно
3. Предлагает пользователю перезапустить
4. При подтверждении:
   - Отправляет `shutdown` с флагом `graceful=true`
   - Ждёт завершения активных операций (max 30s)
   - Останавливает старый процесс
   - Запускает новый процесс
   - Клиенты переподключаются автоматически

### 12.3. Откат
Если новая версия не запускается:
1. Расширение обнаруживает ошибку запуска (timeout 10s)
2. Автоматически откатывается на предыдущую версию
3. Уведомляет пользователя о проблеме
4. Создаёт diagnostic report в `~/.codeai-hub/logs/crash-<timestamp>.json`

### 12.4. Удаление
Команда `CodeAI Hub: Uninstall Core`:
1. Останавливает процесс ядра
2. Предлагает сохранить данные сессий (backup)
3. Удаляет `~/.codeai-hub/core/`
4. Опционально удаляет все данные (`~/.codeai-hub/`)

---

## 13. Тестирование

### 13.1. Unit тесты
- Каждый модуль должен иметь покрытие >= 80%
- Моки для внешних зависимостей (провайдеры, keychain, файловая система)

### 13.2. Integration тесты
- Запуск полного цикла: start → create session → send message → stream response → stop
- Тестирование переподключений WebSocket
- Проверка персистентности после рестарта

### 13.3. E2E тесты
- Запуск с реальными клиентами (VS Code webview, CEF)
- Проверка синхронизации между клиентами
- Тестирование обновлений

### 13.4. Performance тесты
- Load testing: 100+ одновременных подключений
- Stress testing: 1000+ сообщений в минуту
- Memory leak detection

---

## 14. Метрики успеха (Definition of Done для Phase 14)

### 14.1. Функциональные критерии
- ✅ Ядро запускается автоматически при активации расширения
- ✅ VS Code webview подключается к ядру через WebSocket
- ✅ CEF-клиент подключается к тому же ядру
- ✅ Создание сессии с mock-провайдером работает
- ✅ Отправка сообщения и получение mock-ответа работает
- ✅ Синхронизация состояния между webview и CEF работает
- ✅ Ядро продолжает работать после закрытия VS Code
- ✅ Восстановление сессий после перезапуска ядра работает

### 14.2. Нефункциональные критерии
- ✅ Startup time < 5s
- ✅ Memory usage < 500MB для 10 сессий
- ✅ WebSocket latency < 100ms (локальное подключение)
- ✅ Нет memory leaks при длительной работе (24h+)

### 14.3. Качество кода
- ✅ TypeScript без `any` (кроме edge cases)
- ✅ Ultracite (Biome) проходит без ошибок
- ✅ Unit тесты покрытие >= 80%
- ✅ Документация API полная (JSDoc)

---

## 15. Открытые вопросы (для обсуждения)

### 15.1. Архитектурные решения
- **Q1**: Использовать ли встроенную SQLite для персистентности или продолжить с JSONL?
  - **Плюсы SQLite**: Быстрые запросы, индексы, транзакции
  - **Плюсы JSONL**: Простота, читаемость, git-friendly
  - **Предложение**: JSONL для MVP, SQLite для оптимизации позже

- **Q2**: Как упаковывать ядро — pkg (single binary) или distributable node_modules?
  - **pkg**: Один исполняемый файл, проще установка, больше размер (~45MB)
  - **node_modules**: Меньше размер, сложнее установка, требует Node.js
  - **Предложение**: pkg для кросс-платформенности

- **Q3**: Автозапуск ядра при старте системы?
  - **За**: Мгновенный доступ к сессиям, ядро всегда готово
  - **Против**: Использование ресурсов, privacy concerns
  - **Предложение**: Опциональная настройка, по умолчанию выключена

### 15.2. Функциональность
- **Q4**: Поддержка мультипользовательского режима (несколько пользователей на одной машине)?
  - **Сложность**: Изоляция данных, отдельные порты, управление доступом
  - **Предложение**: Отложить на будущее, пока не востребовано

- **Q5**: Механизм плагинов для расширения функциональности ядра?
  - **Примеры**: Custom визарды, интеграции с внешними сервисами
  - **Предложение**: Заложить архитектуру, реализация после MVP

- **Q6**: Уровень изоляции провайдеров — процессы или просто модули?
  - **Процессы**: Полная изоляция, защита от падений, больше overhead
  - **Модули**: Проще, быстрее, меньше защиты
  - **Предложение**: Модули для MVP, процессы при необходимости

### 15.3. Безопасность
- **Q7**: Обязательная авторизация для локальных подключений?
  - **За**: Защита от локальных exploit
  - **Против**: Усложнение UX для single-user сценариев
  - **Предложение**: Опциональная, включается для удалённого доступа

- **Q8**: Шифрование WebSocket траффика (wss://) для локальных подключений?
  - **За**: Дополнительная защита
  - **Против**: Overhead, сложность сертификатов
  - **Предложение**: Только для удалённого доступа

### 15.4. Производительность
- **Q9**: Лимиты на количество сессий/клиентов?
  - **Предложение**: 10 активных сессий, 5 одновременных клиентов (настраивается)

- **Q10**: Стратегия кэширования ответов провайдеров?
  - **Потенциал**: Экономия токенов для повторяющихся запросов
  - **Риски**: Устаревшие данные, усложнение логики
  - **Предложение**: Отложить, оценить после реальной эксплуатации

---

## 16. Roadmap

### Phase 10 ✅ (Завершена)
- Создание структуры packages/core/
- Настройка npm workspaces и инструментов сборки
- Создание манифестов и установщика

### Phase 10А 🔄 (Текущая)
- Создание данной спецификации
- Обсуждение с пользователем
- Согласование архитектурных решений

### Phase 11 📋 (Следующая)
- Детальное проектирование модулей
- Создание Mermaid-диаграмм взаимодействия
- Определение всех интерфейсов и контрактов
- Обновление Architecture.md

### Phase 12
- Реализация точки входа и базового запуска
- Создание заглушек всех модулей
- Базовый HTTP server с health check
- Тестирование ручного запуска

### Phase 13
- Реализация WebSocket hub
- Токен-авторизация
- Подключение VS Code webview
- Подключение CEF-клиента

### Phase 14
- Mock-провайдеры для тестирования
- Интеграционное тестирование полного цикла
- Проверка синхронизации между клиентами
- Сборка релиза и документация

---

## 17. Справочная информация

### 17.1. Связанные документы
- `doc/Architecture/Architecture.md`
- `doc/Project_Docs/SystemArchitecture/SystemArchitecture.md`
- `doc/Project_Docs/Stacks/CEF_DeliveryPlan.md`
- `doc/TODO/todo-plan.md`

### 17.2. Внешние ресурсы
- [Node.js Documentation](https://nodejs.org/docs/)
- [WebSocket Protocol RFC 6455](https://tools.ietf.org/html/rfc6455)
- [JWT RFC 7519](https://tools.ietf.org/html/rfc7519)
- [TOTP RFC 6238](https://tools.ietf.org/html/rfc6238)

### 17.3. История изменений
- **2025-10-24 v0.1.0-draft**: Первая версия спецификации (Phase 10А)

---

## Заключение

Данный документ является рабочим черновиком и будет дополнен после обсуждения с пользователем. Все открытые вопросы требуют принятия решений перед переходом к Phase 11 (проектирование).

**Следующие шаги**:
1. Обсудить архитектурные решения (раздел 15)
2. Согласовать user journeys и приоритеты
3. Уточнить требования к производительности
4. Принять решения по безопасности
5. Обновить спецификацию и перейти к Phase 11
